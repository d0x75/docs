Article : https://web.archive.org/web/20171225205827/http://www.numaboa.com.br/informatica/oraculo/formato-padrao/1096-formato-pe?showall=&limitstart=


# Aldeia NumaBoa 0x00 - Informática Numaboa - Referências - O formato PE


## O formato PE


Qualquer executável win32 (exceto VxD e DLLs de 16 bits) usa o formato PE de arquivo, ou seja, obedecem a um padrão de armazenamento

PE vem de Portable Executable e é um formato de binários executáveis (DLLs e programas) para windows NT, windows 9x e win32s. Também pode ser utilizado para arquivos de objetos e bibliotecas (libraries).

PE vem de Portable Executable e é um formato de binários executáveis (DLLs e programas) para windows NT, windows 9x e win32s. Também pode ser utilizado para arquivos de objetos e bibliotecas (libraries).

Parece brincadeira, mas não é: o stub é um executável DOS completo dentro do executável win32. O stub pode simplesmente mostrar uma string do tipo "This program cannot be run in DOS mode" ou ser um programa DOS completo. Dependendo da vontade do programador, muita coisa pode rolar antes que o executável win32 comece a ser executado.
Stub significa fragmento. O conceito de fragmento do DOS vem desde o tempo dos executáveis de 16 bits do windows (os quais usam o formato NE). O mesmo fragmento é usado em executáveis OS/2, arquivos "self-extracting" e outros aplicativos de 32 bits. Para arquivos PE, o fragmento é um executável compatível com o MS-DOS 2.0, quase sempre constituído por cerca de 100 bytes, cuja função é dar mensagens de erro do tipo "este programa precisa do windows...".


---

## Cabeçalho e Stub do DOS

A área destacada em azul é o stub do DOS. Uma parte dos valores tem o correspondente em ASCII de "This program cannot be run in DOS mode", que é a string que será mostrada caso se tente executar este programa a partir do DOS. Antes da String mencionada acima , geralmente tem o código usa o serviço 9 da interrupção 21 do DOS para imprimir uma string e o serviço 4C da interrupção 21 para voltar ao ambiente DOS. A instrução de interrupção é CD 21 e as instruções estão destacadas em azul mais claro.

Pressupõem-se que todo arquivo que contenha uma assinatura PE seja um arquivo PE válido - pelo menos o Windows "pensa" assim.


---


## Cabeçalho do arquivo


Os componentes do cabeçalho do arquivo são os seguintes:

Assinatura do cabeçalho PE

		4550000

Tipo de máquina previsto para rodar o executável


		IMAGE_FILE_MACHINE_I386		014C	processador Intel 80386 ou melhor
		Intel 486 					014D	processador Intel 80486 ou melhor
		Intel Pentium 				014E	processador Intel Pentium ou melhor
		MIPS 						0160	E3000 (MIPS), big endian
		IMAGE_FILE_MACHINE_R3000	0162	R3000 (MIPS), little endian
		IMAGE_FILE_MACHINE_R4000	0166	R4000 (MIPS), little endian
		IMAGE_FILE_MACHINE_R10000	0168	R10000 (MIPS), little endian
		IMAGE_FILE_MACHINE_ALPHA	0184	DEC Alpha AXP
		IMAGE_FILE_MACHINE_POWERPC	01F0	IBM Power PC, little endian

Número de seções
		
		Indica o número de seções após o cabeçalho PE

TimeDateStamp
		
		Valor de 32 bits que é um carimbo de data/hora do momento da criação do arquivo.
		Aparentemente corresponde ao número de segundos decorridos a partir de 1 de Janeiro de 1970 00:00:00, em UTC - o formato utilizado pela maioria dos compiladores C para time_t. Este carimbo é utilizado para a união de diretórios de importação, os quais serão abordados adiante.

		PS: alguns linkers costumam atribuir valores absurdos ao carimbo, fora dos padrões time_t descritos acima.

		Invertendo os bytes, o TimeDateStamp do nosso executável exemplo mostra um valor hexadecimal de 3C55 77A3 que corresponde a 1.012.234.147 decimal. Sabendo que este valor é o número de segundos decorridos a partir de 01.01.70 e que cada dia possui 86.400 segundos, podemos calcular que o binário em questão foi criado 11.716 dias (um pouquinho menos) após o início de 1970

Ponteiro para Tabela de Símbolos e Número de Símbolos

		Os componentes "PointerToSymbolTable" (ponteiro para a tabela de símbolos) e "NumberOfSymbols" (número de símbolos), ambos de 32 bits, são utilizados para fins de debug. Não sei como decifrá-los e, geralmente, estão zerados
		

Tamanho do Cabeçalho Opcional
		
		O "SizeOfOptionalHeader" (tamanho do cabeçalho opcional), de 16 bits, é simplesmente o tamanho do IMAGE_OPTIONAL_HEADER. Pode ser utilizado para verificar se a estrutura do arquivo PE está correta

Características


tem 16 bits e consiste num conjunto de flags, a maioria válida apenas para arquivos objeto e bibliotecas:
quando setados como = 1 estão ligados e quando estão = 0 desligados.

0 - IMAGE_FILE_RELOCS_STRIPPED :	
Se não houver informações de remanejamento no arquivo. Isto se refere a informações de remanejamento por seção nas próprias seções. Não é utilizado em executáveis, os quais possuem informações de remanejamento no diretório "base relocation" descrito abaixo.

1 - IMAGE_FILE_EXECUTABLE_IMAGE : 
Se o arquivo for um executável, isto é, não é nem um arquivo objeto nem uma biblioteca. Esta flag também pode estar setada se a tentativa do linker em criar um executável tenha falhado por algum motivo - a imagem é mantida para facilitar uma linkagem incremental numa próxima tentativa.

2 - IMAGE_FILE_LINE_NUMS_STRIPPED	Se a informação do número de linha tiver sido eliminada. Não é usado em executáveis.

3 - IMAGE_FILE_LOCAL_SYMS_STRIPPED	Se não houver informação sobre símbolos locais. Não é usado em executáveis.

4 - IMAGE_FILE_AGGRESIVE_WS_TRIM	Se o sistema operacional deve cortar agressivamente o conjunto de trabalho do processo em andamento (a quantidade de RAM que o processo utiliza) através de um 'paging out'. Este bit deve ser setado apenas em aplicativos tipo demon que, na maior parte do tempo, ficam em estado de espera.

7 - IMAGE_FILE_BYTES_REVERSED_LO	Assim como seu par, o bit 15, está setado se o endian do arquivo não corresponder ao esperado pela máquina, de modo que precisa haver uma troca de bytes antes que uma leitura seja efetuada. Esta flag não é confiável para arquivos executáveis - o sistema operacional conta com os bytes devidamente ordenados nos executáveis.

8 - IMAGE_FILE_32BIT_MACHINE	Se for para rodar numa máquina de 32 bits.

9 - IMAGE_FILE_DEBUG_STRIPPED	Se não houver informação de debug no arquivo. Não é utilizado para executáveis. De acordo com outras informações ([6]), este bit é denominado de "fixo" e é setado se a imagem só puder rodar se estiver mapeada no endereço preferido (ou seja, não permite remanejamento).

10 - IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP	Se o aplicativo não puder rodar a partir de um meio removível, como um disquete ou CD-ROM. Neste caso, o sistema operacional é informado para copiar o arquivo para um arquivo temporário ("swapfile") e executá-lo a partir da cópia.

11 - IMAGE_FILE_NET_RUN_FROM_SWAP	Se o aplicativo não puder ser executado em rede. Neste caso, o sistema operacional é informado para copiar o arquivo para um arquivo temporário local ("swapfile") e executá-lo a partir da cópia.

12 - IMAGE_FILE_SYSTEM	Se o arquivo for um arquivo de sistema, por exemplo, um driver. Não é utilizado em executáveis. Também não é usado em todos os drivers NT.

13 - IMAGE_FILE_DLL	Se o arquivo for uma DLL.

14 - IMAGE_FILE_UP_SYSTEM_ONLY	Se o arquivo não tiver sido projetado para rodar em sistemas multiprocessados, ou seja, travará porque depende, de algum modo, de um único processador.

15 - IMAGE_FILE_BYTES_REVERSED_HI	Veja Bit 7.


As coisas começam a ficar um pouco mais complexas porque algumas partes do arquivo PE (as seções) não estão necessariamente alinhadas da mesma forma que a imagem mapeada. Por exemplo, as seções do arquivo em disco geralmente estão alinhadas em limites de 512 bytes, enquanto que a imagem mapeada na memória provavelmente esteja alinhada em limites de 4096 bytes


----

## Cabeçalho opcional


Este cabeçalho contém informações de como o arquivo PE deve ser tratado. Os componentes do cabeçalho opcional são os seguintes:


Magic
		
		O primeiro word de 16 bits do cabeçalho opcional é o 'Magic'. Em todos os arquivos PE que analisei até hoje, o valor encontrado sempre foi 010B.

MajorLinkerVersion e MinorLinkerVersion


		O próximo componente do cabeçalho opcional, composto de 2 bytes, reflete as versões Maior e Menor do linker utilizado. Estes valores, novamente, não são confiáveis e nem sempre refletem apropriadamente a versão do linker.

Tamanho do Código, Segmento de Dados e Segmento BSS
		
		Os 3 valores de 32 bits seguintes referem-se ao Tamanho do Código Executável ('SizeOfCode'), ao Tamanho dos Dados Inicializados ('SizeOfInitializedCode') e ao Tamanho dos Dados não Inicializados ('SizeOfUninitializedCode'). O tamanho dos dados inicializados também é conhecido como Segmento de Dados (Data Segment) e o tamanho dos dados não inicializados é conhecido como Segmento BSS (BSS Segment). Estes dados, uma vez mais, não são confiáveis! Por exemplo: o segmento de dados pode estar dividido em vários segmentos por ação do compilador ou do linker.S

AddressOfEntryPoint - O Ponto de Entrada do Código do Executável
		
		RVA referente ao inicio da sessão de código executável na memória.
		Somando o RVA com o endereço base do executável, chegamos no entry point do binário.

Base do Código e Base dos Dados

		Logo após o importantíssimo Ponto de Entrada encontram-se dois valores de 32 bits, o 'BaseOfCode' (base do código) e o 'BaseOfData' (base dos dados), ambos também RVAs. Infelizmente os dois também perdem importância (como tantos outros campos) por que a informação obtida através da análise das seções é muito mais confiável.


Base da Imagem
		
		Segue uma entrada de um valor de 32 bits que indica o endereço de mapeamento preferencial, chamado de endereço linear e correspondendo à 'BaseImage'

		Segue uma entrada de um valor de 32 bits que indica o endereço de mapeamento preferencial, chamado de endereço linear e correspondendo à 'BaseImage'. No momento da execução, se este endereço de memória estiver vago, o binário inteiro (incluindo os cabeçalhos) será transferido para lá. Este é o endereço, sempre um múltiplo de 64, para onde o binário é remanejado pelo linker. Se o endereço estiver disponível, o carregador (loader) não precisará remanejar o arquivo, o que representa um ganho no tempo de carregamento.



Alinhamento

		
		Os dois valores de 32 bits seguintes são os alinhamentos das seções do arquivo PE na RAM ('SectionAlignment', quando a imagem estiver carregada na memória) e no arquivo em disco ('FileAlignment'). Geralmente ambos valores são 32, ou então FileAlignment (alinhamento de arquivo) é 512 e SectionAlignment (alinhamento de seções) é 4096. As seções serão vistas posteriormente.

Versão do Sistema Operacional

		
		Os dois valores seguintes são de 16 bits e referem-se à versão esperada do sistema operacional ('MajorOperatingSystemVersion' e 'MinorOperatingSystemVersion'). Esta informação da versão é apenas para o sistema operaconal, por exemplo NT ou Win98, ao contrário da versão do sub-sistema, por exemplo Win32. Geralmente esta informação não é fornecida ou está errada.


Versão do Binário

		Os dois valores de 16 bits seguintes fornecem a versão do binário ('MajorImageVersion' e 'MinorImageVersion'). Muitos linkers não fornecem dados corretos e uma grande parte dos programadores nem se dá ao trabalho de fornecê-los.


Versão do Subsistema
		
		Os próximos 2 words de 16 bits são para a versão do sub-sistema esperado ('MajorSubsystemVersion' e 'MinorSubsystemVersion'). Esta versão deveria ser Win32 ou POSIX, por que os programas de 16 bits ou os do OS/2 obviamente não estão em formato PE.

		Esta versão de subsistema deve ser fornecida corretamente porque ela É checada e usada:

		Se o aplicativo for um do tipo Win32-GUI, tiver que rodar em NT4 e a versão do sub-sistema não for 4.0, as caixas de diálogo não terão o estilo 3D e alguns outros aspectos terão a aparência do "estilo antigo". Isto porque o aplicativo acaba sendo rodado no NT 3.51, o qual possui o program manager ao invés do explorer, etc, e o NT 4.0 tentará imitar o 3.51 da melhor maneira possível.

Versão do Win32
		
		Só Deus sabe para é que serve este próximo valor de 32 bits. Está sempre zerado (veja acima).

Tamanho da Imagem

		Este valor de 32 bits indica a quantidade de memória necessária para abrigar a imagem, em bytes ('SizeOfImage'). É a soma do comprimento de todos os cabeçalhos e seções, se estiverem alinhados de acordo com o 'SectionAlignement'. Indica para o carregador quantas páginas serão necessárias para carregar completamente a imagem.

Tamanho dos Cabeçalhos
		
		O próximo valor de 32 bits é o tamanho de todos os cabeçalhos, incluindo os diretórios de dados e os cabeçalhos das seções ('SizeOfHeaders'). Representa o offset do início do arquivo até os dados (raw data) da primeira seção.

CheckSum

		Segue-se o valor de 32 bits do 'CheckSum'. O valor do checksum, para as versões atuais do NT, só é checado se a imagem for um driver NT (o driver não carregará se o checksum não estiver correto). Para outros tipos de binários o checksum não precisa ser fornecido e pode ser 0.

		O algoritmo para calcular o checksum é propriedade da Microsoft e o pessoal da MS não entrega o ouro. No entanto, diversas ferramentas do Win32 SDK calculam e/ou inserem um checksum válido. Além disto, a função CheckSumMappedFile(), que faz parte da imagehelp.dll, também faz o serviço completo.

		A função do checksum é a de evitar que binários "bichados", que vão dar pau de qualquer forma, sejam carregados - e um driver com pau acaba em BSOD, portanto, é melhor nem carregar.

Subsistema NT

O próximo valor de 16 bits, o 'Subsystem', indica em qual subsistema do NT a imagem deve rodar:

		IMAGE_SUBSYSTEM_NATIVE	1 - O binário não precisa de um subsistema. É usado para drivers.

		IMAGE_SUBSYSTEM_WINDOWS_GUI	2 - A imagem é um binário Win32 gráfico. Ainda pode abrir um console com AllocConsole(), porém não abre automaticamente no startup.

		IMAGE_SUBSYSTEM_WINDOWS_CUI	3 - O binário é um Win32 de console. Receberá um console no startup (default) ou herda um console (parent's console).

		IMAGE_SUBSYSTEM_OS2_CUI	5 - O binário é um OS/2 de console. Os binários OS/2 estarão em formato OS/2, portanto, este valor raramente será encontrado num arquivo PE.

		IMAGE_SUBSYSTEM_POSIX_CUI - 7	O binário usa um subsistema de console POSIX.

		Binários do Windows 9x sempre usarão o subsistema Win32, portanto, os únicos valores aceitáveis para estes binários são 2 e 3. Desconheço se binários "nativos" do windows 9x são aceitos.

Características de DLL


		Este próximo valor de 16 bits indica quando o ponto de entrada deve ser chamado, SE a imagem for de uma DLL. No nosso exemplo, este valor está logicamente zerado (veja acima). Este é mais um campo que parece não ter uso: aparentemente, as DLL recebem notificações de tudo e prescindem deste campo. Novamente os bits são usados para guardar informações:

		Bit	Setado (valor 1)
		0	Notifica uma anexação de processo (isto é, DLL load)
		1	Notifica um desligamento de thread (isto é, termina um thread ativo)
		2	Notifica uma anexação de thread (isto é, cria um thread novo)
		3	Notifica um desligamento de processo (isto é, DLL unload)

Tamanho da Reserva de Pilha (StackReserve)


		Os próximos 4 valores de 32 bits são o tamanho da reserva de pilha ('SizeOfStackReserve'), o tamanho do commit inicial da pilha ('SizeOfStackCommit'), o tamanho da reserva de heap ('SizeOfHeapReserve') e o tamanho do commit do heap ('SizeOfHeapCommit').

		As quantidades 'reservadas' são espaços endereçados (não RAM real) que são reservados para um propósito específico. No início do programa, a quantidade "committada" é alocada na RAM. O valor "committado" é também o quanto a pilha ou o heap "committados" irão crescer caso for necessário. Alguns autores alegam que a pilha cresce em páginas, independentemente do valor do 'SizeOfStackCommit'.

		Vamos a um exemplo: se o programa possui uma reserva de heap de 1 MB e um commit de heap de 64 Kb, o heap começa com 64 Kb e pode ser expandido até 1 MB. O heap irá crescer de 64 em 64 Kb. O 'heap' neste contexto é o heap primário (default). Um processo pode criar mais heaps se houver necessidade.

		Como as DLLs não possuem pilha ou heap próprios, estes valores são ignorados nas suas imagens.

Loader Flags


		Os próximos 32 bits são das 'LoaderFlags' (flags do carregador) para as quais não há uma descrição adequada. No nosso exemplo, de qualquer maneira, todas as flags estão zeradas (veja acima).


Número e Tamanho dos RVA


		O número e tamanho dos RVAs ('NumberOfRvaAndSizes') se encontram nos 32 bits seguintes e revelam o número de entradas válidas nos diretórios que vêm logo a seguir. Este número parece não ser muito confiável. No nosso exemplo, veja também acima, são 16 (1000 0000 -> invertendo 0000 0010 -> 16 decimal).


---

## Diretório de dados


		IMAGE_DIRECTORY_ENTRY_EXPORT	- 0 : É o diretório de funções exportadas, usado principalmente para DLLs.
		IMAGE_DIRECTORY_ENTRY_IMPORT	- 1 : Diretório de símbolos importados.
		IMAGE_DIRECTORY_ENTRY_RESOURCE	- 2 : Diretório de recursos (resources).
		IMAGE_DIRECTORY_ENTRY_EXCEPTION	- 3 : Diretório de exceções - estrutura e aplicação ignorada.
		IMAGE_DIRECTORY_ENTRY_SECURITY	- 4 : Diretório de segurança - estrutura e aplicação ignorada.
		IMAGE_DIRECTORY_ENTRY_BASERELOC	- 5 : Tabela da base de remanejamento.
		IMAGE_DIRECTORY_ENTRY_DEBUG	    - 6 : Diretório de debug, cujo conteúdo depende do compilador. De qualquer forma, muitos compiladores colocam as informações de debug na seção de código e não criam uma seção separada.

		IMAGE_DIRECTORY_ENTRY_COPYRIGHT	- 7 : String de descrição com alguns comentários de copyright ou coisa parecida.
		IMAGE_DIRECTORY_ENTRY_GLOBALPTR	- 8	: Valor de Máquina (MIPS GP) - estrutura e aplicação ignorada.
		IMAGE_DIRECTORY_ENTRY_TLS       - 9	: Diretório de armazenamento local de thread - estrutura desconhecida. Contém variáveis que são declaradas "declspec(thread)", isto é, variáveis globais per-thread.

		IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG-10 : Diretório de configuração de carregamento - estrutura e aplicação ignorada.
		IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT-11: Diretório de importação casada (bound import).
		IMAGE_DIRECTORY_ENTRY_IAT	12	Tabela de endereços de importação (IAT - Import Address Table).


		Se algum diretório de um tipo em particular não for usado no binário, o tamanho (Size) e o endereço virtual (VirtualAddress) são zero.


## Cabeçalho das seções

		As seções são compostas por duas partes principais: primeiro, a descrição da seção (do tipo IMAGE_SECTION_HEADER) e depois os dados propriamente ditos. Desta forma, logo após os diretórios de dados, encontramos um array de cabeçalhos de seções do tipo número de seções ('NumberOfSections'), ordenado pelos RVAs das seções. Um cabeçalho de seção contém:

		Um array de Nomes das Seções

		O primeiro componente é um array de IMAGE_SIZEOF_SHORT_NAME de 8 bytes para guardar o nome (ASCII) da seção. Se todos os 8 bytes forem usados não existe um terminador 0 (zero) para a string! O nome é tipicamente algo como ".data" ou ".text" ou mesmo ".bss". Não há a necessidade do nome ser precedido por um ponto '.' e não existem nome predefinidos (qualquer nome é aceito).

		Os nomes também não têm qualquer relação com o conteúdo da seção. Uma seção de nome ".code" pode ou não conter código executável: pode perfeitamente conter a tabela de endereços de importação, pode conter código executável E a tabela de endereços de importação e até os dados inicializados.

		Para achar informações nas seções, é preciso buscá-las nos diretórios de dados do cabeçalho opcional. Não se deixe influenciar pelo nome da seção e não assuma que os dados da seção estejam logo no início da mesma.

		Endereço Físico e do Tamanho Virtual

		O próximo membro da IMAGE_SECTION_HEADER é a união de 32 bits do Endereço Físico ('PhysicalAddress') e do Tamanho Virtual ('VirtualSize'). Num arquivo objeto, este é o endereço para o qual o conteúdo é remanejado; num executável, é o tamanho do conteúdo. Mais uma vez, este campo não é utilizado! Há linkadores que o preenchem com o tamanho, outros com o endereço e outros ainda que o preenchem com 0. Apesar disso, os executáveis não apresentam problemas.

		Endereço Virtual

		Logo a seguir vem o Endereço Virtual ('VirtualAddress'), um valor de 32 bits que contém o RVA para os dados da seção quando esta estiver mapeada na RAM

		Tamanho dos Dados

		Após o endereço virtual vêm 32 bits para os Tamanho dos Dados ('SizeOfRawData'), que nada mais é do que o tamanho dos dados da seção arredondado para cima, para o próximo múltiplo de 'FileAlignment' (alinhamento de arquivo).


		Ponteiro para os Dados

		Segue-se o Ponteiro para os Dados ('PointerToRawData'), também de 32 bits. Este ponteiro é extremamente útil porque é o offset do início do arquivo em disco até os dados da seção. Se for 0, os dados da seção não estão contidos no arquivo e serão carregados arbitrariamente no momento da carga do programa.

		Ponteiro para Remanejamento

		A seguir vem o Ponteiro para Remanejamento ('PointerToRelocations') de 32 bits e o Ponteiro para Números de Linha ('PointerToLinenumbers'), também de 32 bits, o Número de Remanejamentos ('NumberOfRelocations') de 16 bits e o Número de Números de Linha ('NumberOfLinenumbers'), também de 16 bits. Todas estas informações somente são utilizadas para arquivos objeto. Os executáveis não possuem um diretório de remanejamento base especial e a informação de número de linha, se é que está presente, geralmente está localizada num segmento especial para debugging ou em qualquer outro lugar.

		Características

		O último membro dos cabeçalhos das seções é o valor de 32 bits com as Características. São um punhado de flags que descrevem como a memória das seções deve ser tratada:


IMAGE_SCN_CNT_CODE	5	A seção contém código executável.

IMAGE_SCN_CNT_INITIALIZED_DATA	6	A seção contém dados que recebem um valor definido antes que a execução se inicie. Em outras palavras: os dados da seção são significativos.

IMAGE_SCN_CNT_UNINITIALIZED_DATA	7	A seção contém dados não inicializados que terão todos os bytes zerados antes que a execução se inicie. Este, geralmente, é o BSS.

IMAGE_SCN_LNK_INFO	9	A seção não contém dados de imagem e sim comentários, descrições ou outra documentação qualquer. Esta informação faz parte de arquivos objeto e pode ser a informação para o linker, como, por exemplo, as bibliotecas necessárias.

IMAGE_SCN_LNK_REMOVE	11	Os dados fazem parte de uma seção de um arquivo objeto que deve ser deixado de fora quando o arquivo executável for linkado. Com frequência este bit está combinado com o bit 9.

IMAGE_SCN_LNK_COMDAT	12	A seção contém o "common block data", que são funções de pacotes.

IMAGE_SCN_MEM_FARDATA	15	Existe 'far data' - significado incerto.

IMAGE_SCN_MEM_PURGEABLE	17	Os dados da seção podem sofrer um 'purge' - não é o mesmo que descartáveis, pois há um bit para este fim (veja abaixo). O mesmo bit, aparentemente, é usado para indicar informações de 16 bits - significado incerto.

IMAGE_SCN_MEM_LOCKED	18	Significado incerto - a seção não pode ser deslocada na memória? - não há informação de remanejamento?

IMAGE_SCN_MEM_PRELOAD	19	Significado incerto - a seção deve ser "paginada" antes do início da execução?

20 a 23	Especificam um alinhamento. Não há informações disponíveis. Existe um #define IMAGE_SCN_ALIGN_16BYTES e parecidos...

IMAGE_SCN_LNK_NRELOC_OVFL	24	A seção contém alguns remanejamentos extendidos - significado incerto.

IMAGE_SCN_MEM_DISCARDABLE	25	Os dados da seção não são necessários após o início do processo. É o caso, por exemplo, das informações de remanejamento. São encontradas também para rotinas de startup de drivers e serviços que são executados apenas uma vez e para diretórios de importação.

IMAGE_SCN_MEM_NOT_CACHED	26	Os dados da seção não devem ir para cache. (Será que significa desligar o cache de segundo nível?)

IMAGE_SCN_MEM_NOT_PAGED	27	Os dados da seção não devem sair da página. Isto é interessante para drivers.

IMAGE_SCN_MEM_SHARED	28	Os dados da seção são compartilhados entre todas as instâncias das imagens que estiverem
sendo executadas. Se forem os dados inicializados de uma DLL, por exemplo, todos os conteúdos das mesmas variáveis serão os mesmos em todas as instâncias da DLL. Note que apenas a seção da primeira instância é inicializada. Seções contendo código são sempre compartilhadas copy-on-write, isto é, o compartilhamento não funciona se houver a necessidade de fazer remanejamentos.

IMAGE_SCN_MEM_EXECUTE	29	O processo recebe acesso de 'execução' na memória da seção.

IMAGE_SCN_MEM_READ	30	O processo recebe acesso de 'leitura' na memória da seção.

IMAGE_SCN_MEM_WRITE	31	O processo recebe acesso de 'escrita' na memória da seção.


``
Hexa      - 60000020
Binário	  - 11000000000000000000000010000000
Flag Bits - 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
``

	elevante na seção .text são os seguintes bits:

	Bit 5 = 0: A seção NÃO contém código executável.
	Bit 7 = 1: A seção contém dados não inicializados.
	Bit 29 = 0: O processo NÃO recebe acesso de 'execução'.
	Bit 30 = 1: O processo recebe acesso de 'leitura'.
	Bit 31 = 1: O processo recebe acesso de 'escrita'.

---


## Seções


Após os cabeçalhos das seções seguem as seções propriamente ditas com os dados nus (raw data). 

Após os cabeçalhos das seções seguem as seções propriamente ditas com os dados nus (raw data). Dentro do arquivo, elas estão alinhadas em 'FileAlignment' bytes, ou seja, após o cabeçalho opcional e após cada uma das seções haverá bytes zerados de preenchimento para atingir o tamanho 'FileAlignment'. Além disto, estão ordenadas pelos seus RVAs. Quando carregadas na RAM, as seções são alinhadas de acordo com o 'SectionAlignment'.

Exemplificando: se o cabeçalho opcional, no arquivo, terminar no offset 981 e o 'FileAlignment' for 512, a primeira seção começará no byte 1024. Note que é possível encontrar o início das seções através do Ponteiro de Dados ('PointerToRawData') ou através do Endereço Virtual ('VirtualAddress') de modo que, dificilmente, será necessário ficar perdendo tempo com alinhamentos.

Existe um cabeçalho de seção para cada seção e cada diretório de dados apontará para uma das seções. Vários diretórios de dados podem apontar para a mesma seção e também podem existir seções que não sejam apontadas pelo diretório de dados.

Os tópicos cobertos neste texto são os seguintes:


- Considerações gerais

Repetindo: todas as seções estão alinhadas pelo 'SectionAlignment' quando mapeadas na RAM e pelo 'FileAlignment' quando no arquivo em disco (se necessário, reveja em cabeçalho opcional). As seções são descritas através de entradas nos cabeçalhos das seções - encontra-se o início das seções no arquivo em disco através do 'PointerToRawData' e na memória através do 'VirtualAddress'; o tamanho está em 'SizeOfRawData' (se necessário, reveja em cabeçalho das seções).

Existem vários tipos de seções, dependendo do seu conteúdo. Na maioria dos casos (mas não em todos) existe um diretório de dados numa seção, indicado com um ponteiro residente no array do diretório de dados do cabeçalho opcional.

- Seção 'code'

Esta seção tem, no mínimo, os bits 'IMAGE_SCN_CNT_CODE', 'IMAGE_SCN_MEM_EXECUTE' e 'IMAGE_SCN_MEM_READ' setados com valor 1 (se necessário, reveja em cabeçalho das seções) e o 'AddressOfEntryPoint' apontará para algum lugar dentro desta seção onde está o início da função que o programador determinou como a primeira a ser executada (se necessário, reveja em cabeçalho opcional).

'BaseOfCode' normalmente apontará para o início desta seção, porém pode apontar além do início se alguns bytes que não são código forem colocados antes do código propriamente dito (se necessário, reveja em cabeçalho opcional).

Geralmente não existe nada além de código executável nesta seção e haverá apenas uma seção com o nome 'code', porém não se fie nisso.

Nomes típicos para esta seção de código executável são ".text", ".code", "AUTO" e coisas do gênero.

- Seção 'data'

O próximo assunto será sobre variáveis inicializadas. Esta seção contém variáveis estáticas inicializadas (do tipo "static int i = 5;"). Terá, no mínimo, os bits 'IMAGE_SCN_CNT_INITIALIZED_DATA', 'IMAGE_SCN_MEM_READ' e 'IMAGE_SCN_MEM_WRITE' setados com valor 1 (se necessário, reveja em cabeçalho das seções). Alguns linkers podem colocar constantes em uma seção própria que não possui o bit 'writeable' (escrita permitida). Se parte dos dados for compartilhável ou se existirem outras peculiaridades, pode haver outras seções com os bits de seção apropriadamente setados.

A seção (ou seções) estará situada entre 'BaseOfData' e 'BaseOfData' + 'SizeOfInitializedData'.

Nomes típicos para esta seção são ".data", ".idata", "DATA" e parecidos.

O Ponteiro para os Dados ('PointerToRawData') é o offset do início do arquivo em disco até os dados desta seção. No programa exemplo encontramos o valor 0000 0800. Observe os primeiros 16 bytes:



- Seção 'bss'

O assunto seguinte é sobre dados não inicializados (para variáveis estáticas, tipo "static int k;"). Esta seção é bastante parecida com a seção de dados inicializados, porém terá um offset de arquivo em disco ('PointerToRawData') de 0, indicando que seu conteúdo não está armazenado no arquivo. Além disto, 'IMAGE_SCN_CNT_UNINITIALIZED_DATA' está setado com valor 1 ao invés de 'IMAGE_SCN_CNT_INITIALIZED_DATA', indicando que o conteúdo deve ser preenchido com bytes 0 (zero) durante o carregamento. Isto significa que existe um cabeçalho de seção, porém não existe a seção no arquivo. A seção será criada pelo carregador e consistirá inteiramente de bytes 0. O tamanho será de 'SizeOfUninitializedData'.

Nomes típicos são ".bss", "BSS" e parecidos.

Estas são as seções de dados que NÃO são apontadas através de diretórios de dados. Seu conteúdo e estrutura são fornecidos pelo compilador e não pelo linker.

(O segmento de pilha - stack-segment - e o segmento de heap - heap-segment - não são seções do binário. São criados pelo carregador de acordo com os campos stacksize e heapsize do cabeçalho opcional.)

Como o binário usado como exemplo não possui dados não inicializados, o mesmo não possui uma seção deste tipo.	

- Copyright

Para começar com uma seção-diretório simples, vamos dar uma olhada no 'IMAGE_DIRECTORY_ENTRY_COPYRIGHT' do diretório de dados. O conteúdo é um copyright ou uma string descritiva em ASCII (não terminada em 0) como "TallyBan control application, copyright © 1800 NhacaSoft & Cia". Normalmente esta string é fornecida ao linker através da linha de comando ou através de um arquivo de descrição.

Esta string não é necessária em tempo de execução e pode ser descartada. Não tem acesso de escrita - na verdade, o aplicativo não precisa de acesso nenhum. Deste modo, o linker vai constatar se já existe ou não uma seção sem acesso de escrita e descartável. Se não existir, cria uma seção com o nome de ".descr" ou algo parecido, joga a string dentro dela e faz com que o ponteiro de diretório de copyright aponte para a string. O bit 'IMAGE_SCN_CNT_INITIALIZED_DATA' também deve ser setado com valor 1.

O programa exemplo não foi compilado com informações de copyright, portanto, o ponteiro de diretório de copyright contém apenas zeros e o binário não apresenta esta seção.

- Símbolos exportados

A próxima coisa mais simples é o diretório de exportação, 'IMAGE_DIRECTORY_ENTRY_EXPORT'. Este é um diretório tipicamente encontrado em DLLs. Contém os pontos de entrada de funções exportadas (e os endereços de objetos exportados, etc). É claro que executáveis também podem ter símbolos exportados mas, geralmente, não têm.

A seção que abriga símbolos exportados deve ser do tipo "dados inicializados" e "para leitura". Não deve ser "descartável" porque o processo pode chamar um "GetProcAddress()" para procurar um ponto de entrada de uma função em tempo de execução. Esta seção normalmente é denominada de ".edata" se estiver individualizada; com bastante frequência está fundida com alguma outra seção como "dados inicializados".

A estrutura da tabela de exportação ('IMAGE_EXPORT_DIRECTORY') é composta por um cabeçalho e os pelos dados de exportação, ou seja, o nome dos símbolos, seus ordinais e os offsets dos seus pontos de entrada.

Primeiro temos 32 bits de 'Characteristics' que não são utilizados e normalmente são 0. Depois vem um 'TimeDateStamp' de 32 bits, o qual presumivelmente deveria indicar a data e hora em formato time_t em que a tabela foi criada; aliás, nem sempre é válido (alguns linkers lhe atribuem 0). Depois temos 2 words de 16 bits para a informação da versão ('MajorVersion' e 'MinorVersion') e estes, também, com frequência estão zerados.

Os próximos 32 bits são para o nome ('Name'). Este é um RVA para o nome da DLL representada por uma string ASCII terminada em 0 (o nome é necessário caso o arquivo DLL seja renomeado - veja "binding" no diretório de importação). Depois temos a base ('Base') de 32 bits, que será tratada logo a seguir.

O próximo valor de 32 bits é o número total de itens exportados ('NumberOfFunctions'). Além do seu número ordinal identificador, os itens podem ser exportados sob diversos nomes - e o próximo número de 32 bits é o número total de nomes exportados ('NumberOfNames').

Na maioria dos casos, cada item exportado terá exatamente um nome que lhe corresponde e será usado com este nome, porém um item pode ter vários nomes associados (e ser acessado por cada um deles), ou poderá não ter nome algum e só ser acessível através do seu número ordinal. O uso de exportações sem nome (apenas pelo ordinal) é desencorajado porque todas as versões da DLL exportadora precisariam usar a mesma numeração ordinal gerando um problema de manutenção.

O próximo valor de 32 bits, o 'AddressOfFunctions', é um RVA para a lista dos itens exportados. Aponta para um array de valores de 32 bits de 'NumberOfFunctions', cada qual um RVA para a função exportada ou variável.

Há dois desvios nesta lista. Primeiro, o RVA pode ser 0 e, neste caso, não é utilizado. Segundo, se o RVA apontar para uma seção contendo o diretório de exportação, acaba fazendo uma exportação remetida. Uma exportação prematura é um ponteiro para uma exportação em outro binário - se for usado, a exportação apontada no outro binário é que será usada. Neste caso, o RVA aponta, como mencionado, na a seção do diretório de exportação, para uma string terminada em 0 correspondente ao nome da DLL apontada e o nome exportado separados por um ponto, como "outradll.nomeexportado", ou o nome da DLL e o ordinal exportado, como "outradll.#19".

Chegou a hora de explicar o ordinal de exportação. Este ordinal é um índice para o array AddressOfFunctions, a posição baseada em 0 mais a 'Base' mencionada acima.

Na maioria dos casos a base é 1, o que significa que o primeiro exportado tem um ordinal de 1, o segundo de 2 e assim por diante.

Após o RVA 'AddressOfFunctions' encontra-se um RVA para o array de RVAs de 32 bits para os nomes dos símbolos 'AddressOfNames' e um RVA para o array de ordinais de 16 bits 'AddressOfNameOrdinals'. Ambos possuem elementos 'NumberOfNames'.

Os nomes dos símbolos podem simplesmente não existir. Neste caso, 'AddressOfNames' é 0. Caso contrário, os arrays apontados correm em paralelo, significando que seus elementos em cada item estão atrelados. O array 'AddressOfNames' consiste de RVAs para nomes de exportação terminados em 0; os nomes são mantidos numa lista ordenada (isto é, o primeiro membro do array é o RVA para o nome alfabeticamente menor; isto permite uma procura eficiente quando duma procura de um símbolo exportado pelo nome).

De acordo com a especificação do PE, o array 'AddressOfNameOrdinals' possui um ordinal que corresponde a cada um dos nomes. Entretanto, o que pude verificar é que este array contém o índice atual do array 'AddressOfFunctions'.

Segue um esquema das três tabelas:



			'AddressOfFunctions'
			|
			V
			RVA exportado com o ordinal 'Base'
			RVA exportado com o ordinal 'Base' + 1
			...
			RVA exportado com o ordinal 'Base' + 'NumberOfFunctions' - 1



			   'AddressOfNames'                         'AddressOfNameOrdinals'
			           |                                        |
			           V                                        V
			RVA para o primeiro nome        <-> Índice da exportação do primeiro nome
			RVA para o segundo nome         <-> Índice da exportação do segundo nome
			          ,,,                                      ...
			RVA para o nome 'NumberOfNames' <-> Índice da exportação para o nome 'NumberOfNames'


Alguns exemplos para ajudar a entender:

Para achar um símbolo exportado pelo seu ordinal, subtraia a 'Base' para obter o índice, siga o RVA 'AddressOfFunctions' para encontrar o array de exportações e use o índice para achar o RVA exportado no array. Se o RVA não apontar para a seção de exportação, terminou a procura. Caso contrário, ele aponta para uma string que descreve a DLL exportadora e o nome ou o ordinal dentro dela, e você precisa procurar pela exportação remetida adiante.

Para achar um símbolo exportado pelo nome, siga o RVA 'AddressOfNames' (se contiver 0 não existem nomes) para encontrar o array de RVAs para os nomes exportados. Procure o nome desejado na lista. Use o índice do nome no array 'AddressOfNameOrdinals' e obtenha o número de 16 bits correspondente ao nome encontrado. De acordo com a especificação PE, é um ordinal e você precisa subtrair a base para obter o índice de exportação - de acordo com a minha experiência, este já é o índice e você não precisa subtrair a base. Usando o índice de exportação você encontra o RVA de exportação no array 'AddressOfFunctions', sendo ou o próprio RVA de exportação ou um RVA para a string descrevendo uma exportação remetida.


- Símbolos importados


Quando o compilador encontra uma chamada para uma função que esteja localizada num executável à parte (geralmente uma DLL), nos casos mais simples ele desconhece as circunstâncias e simplesmente gera uma instrução de chamada normal para este símbolo, cujo endereço o linker terá que ajustar da mesma maneira como faz para qualquer símbolo externo.

O linker usa uma biblioteca de importações para verificar qual é o símbolo de qual DLL que está sendo importado e produz "stubs" (fragmentos) para todos os símbolos importados. Cada fragmento consiste numa instrução de salto e é o alvo da chamada. Estas instruções de salto provocam um salto para um endereço que está na assim chamada tabela de endereços de importação. Em aplicativos mais sofisticados (quando uma "__declspec(dllimporta)" é usada), o compilador conhece a função importada e produz uma chamada direta para o endereço na tabela de endereços de importação sem fazer uso do salto.

De qualquer forma, o endereço da função na DLL sempre é necessário e será suprido pelo carregador a partir do diretório de exportação da DLL exportadora quando o aplicativo for carregado. Verificando o diretório de importação, o carregador sabe quais símbolos de quais bibliotecas precisam ser verificados e ter seus endereços ajustados.

É melhor dar um exemplo. As chamadas com ou sem __declspec(dllimporta) têm o seguinte aspecto:

fonte:

int symbol(char *); declspec(dllimporta) int symbol2(char*); void foo(void) { int i = symbol("bar"); int j = symbol2("baz"); }
assembly:

... call symbol ; sem declspec(dllimporta) ... call [impsymbol2] ; com declspec(dllimporta) ...
No primeiro caso (sem declspec(dllimporta)), o compilador não sabia que 'symbol' estava numa DLL de modo que o linker precisa prover a função 'symbol'. Já que a função não está disponível, ele gerará um fragmento de função para o símbolo importado, o qual é um salto indireto. A coleção de todos os fragmentos de importação é denominada de "área de transferência" (às vezes também chamada de "trampolim" porque dá-se um salto para ir para um outro lugar).
Esta área de transferência fica tipicamente localizada na seção de código (code section) mas não faz parte do diretório de importação. Cada um dos fragmentos de função é um salto para a função das DLLs alvo. A área de transferência tem o seguinte aspecto:

``
_symbol: jmp [__imp__symbol]
_outrosymbol: jmp [__imp__outro__symbol]
...
``

Isto significa que, se você utilizar símbolos importados sem especificar "declspec(dllimporta), então o linker gerará uma área de transferência para eles composta por saltos indiretos. Se você especificar "declspec(dllimporta)", o compilador fará o redirecionamento e a área de transferência deixa de ser necessária. Isto também significa que, se você importar variáveis ou outra coisa qualquer, é preciso especificar "declspec(dllimporta)" por que um fragmento com uma instrução de salto é apropriado apenas para funções.

Em qualquer caso, o endereço do símbolo 'x' é armazenado no local 'imp_x'. Todos estes locais juntos compõem a assim chamada "tabela de endereços de importação", a qual é fornecida pelo linker através das bibliotecas de importação das várias DLLs que estejam sendo usadas. A tabela de endereços de importação é uma lista de endereços parecida com:


``
__imp_symbol: 0xDEADBEEF
__imp_symbol2: 0x40100
__imp_symbol3: 0x300100
...
``

Esta tabela de endereços de importação faz parte do diretório de importação e é apontada pelo ponteiro de diretório IMAGE_DIRECTORY_ENTRY_IAT (apesar de que, mesmo que alguns linkers não especifiquem esta entrada de diretório, a coisa também funciona perfeitamente; aparentemente, o carregador consegue resolver importações mesmo sem utilizar o diretório IMAGE_DIRECTORY_ENTRY_IAT).

Os endereços desta tabela são desconhecidos para o linker. O linker insere bobagens (RVAs para os nomes das funções; veja abaixo para maiores informações) que são inseridas pelo carregador em tempo de carregamento usando o diretório de exportação da DLL exportadora. A tabela de endereços de importação e como ela é localizada pelo carregador será descrito em maiores detalhes logo adiante.

Observe que esta descrição é específica para C. Existem outros ambientes de desenvolvimento que não utilizam as bibliotecas de importação. Apesar disso, todos precisam gerar uma tabela de endereços de importação a qual eles usam para permitir que seus programas acessem os objetos e funções importadas. Os compiladores C costumam utilizar as bibliotecas de importação porque é de sua conveniência - seus linkers usam as bibliotecas de qualquer forma. Outros ambientes usam, por exemplo, um arquivo descritivo que lista os nomes das DLLs e os nomes das funções necessárias (como o "arquivo de definição de módulo" - "module definition file") ou uma lista no estilo declaração no fonte.

Esta é a forma como as importações são utilizadas pelo código do programa. Agora vamos dar uma olhada em como é construído um diretório de importação para que o carregador possa usá-lo.

O diretório de importação deve residir numa seção que seja de "dados inicializados" ("initialized data") e "para leitura" ("readable").

O diretório de importação é um array de IMAGE_IMPORT_DESCRIPTORs, um para cada DLL usada. A lista é terminada por um IMAGE_IMPORT_DESCRIPTOR inteiramente preenchido com bytes 0.

O IMAGE_IMPORT_DESCRIPTOR é uma estrutura com os seguintes membros:


- *OriginalFirstThunk*: Um RVA (32 bits) apontando para um array terminado em 0 de RVAs para os IMAGE_THUNK_DATAs, cada um descrevendo uma função importada. O array nunca muda.

- *TimeDateStamp*: Um carimbo de 32 bits com vários propósitos. Imagine que o timestamp seja 0 e deixe os casos avançados para mais tarde.

- *ForwarderChain*: O índice de 32 bits do primeiro remetente (forwarder) na lista de funções importadas. Remetentes também é assunto avançado: para principiantes, setar todos os bits em 1.

- *Name*: Um RVA de 32 bits para o nome da DLL (uma string ASCII terminada em 0).

- *FirstThunk*: Um RVA de 32 bits para um array de RVAs terminado em 0 para os IMAGE_THUNK_DATAs, cada um descrevendo uma função importada. O array faz parte da tabela de endereços de importação e será mudado.


- Recursos
- Remanejamentos



---


## Referências


https://tech-zealots.com/malware-analysis/understanding-concepts-of-va-rva-and-offset/

https://bytepointer.com/resources/pe_luevelsmeyer.htm

http://www.csn.ul.ie/~caolan/publink/winresdump/winresdump/doc/msdn_peeringpe.html

https://blog.karatos.in/a?ID=00250-6bc5c9c2-7eb2-4116-b8b6-2a4b05d229cb